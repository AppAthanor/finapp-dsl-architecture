<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FinApp DSL Architecture</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/5.1.0/github-markdown.min.css">
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            line-height: 1.6;
            color: #24292e;
            max-width: 980px;
            margin: 0 auto;
            padding: 20px;
            background-color: #fff;
        }
        .header {
            border-bottom: 1px solid #eaecef;
            margin-bottom: 20px;
            padding-bottom: 20px;
        }
        .header h1 {
            margin: 0;
            color: #0366d6;
            font-weight: 600;
        }
        .toc {
            background-color: #f6f8fa;
            border: 1px solid #e1e4e8;
            border-radius: 6px;
            padding: 15px 20px;
            margin-bottom: 30px;
        }
        .toc h3 {
            margin-top: 0;
        }
        .toc ul {
            padding-left: 20px;
        }
        .toc li {
            margin-bottom: 8px;
        }
        .section {
            margin-bottom: 40px;
        }
        .section h2 {
            margin-top: 0;
            padding-bottom: 10px;
            border-bottom: 1px solid #eaecef;
        }
        code {
            font-family: SFMono-Regular, Consolas, "Liberation Mono", Menlo, monospace;
            background-color: rgba(27, 31, 35, 0.05);
            padding: 0.2em 0.4em;
            border-radius: 3px;
        }
        pre {
            background-color: #f6f8fa;
            padding: 16px;
            border-radius: 6px;
            overflow: auto;
        }
        pre code {
            background-color: transparent;
            padding: 0;
        }
        .note {
            background-color: #f1f8ff;
            border-left: 4px solid #0366d6;
            padding: 15px;
            margin: 20px 0;
            border-radius: 3px;
        }
        .warning {
            background-color: #fff5b1;
            border-left: 4px solid #ff9800;
            padding: 15px;
            margin: 20px 0;
            border-radius: 3px;
        }
        footer {
            margin-top: 50px;
            padding-top: 20px;
            border-top: 1px solid #eaecef;
            color: #586069;
            font-size: 14px;
        }
        a.home {
            display: inline-block;
            margin-bottom: 20px;
            color: #0366d6;
            text-decoration: none;
        }
        a.home:hover {
            text-decoration: underline;
        }
        .diagram {
            text-align: center;
            margin: 20px 0;
        }
        .code-comparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }
    </style>
</head>
<body>
    <a href="../../index.html" class="home">‚Üê Back to Home</a>
    
    <div class="header">
        <h1>FinApp DSL Architecture</h1>
        <p>Understanding how .finapp files and Clojure implementations work together</p>
    </div>

    <div class="toc">
        <h3>Table of Contents</h3>
        <ul>
            <li><a href="#architecture-overview">Architecture Overview</a></li>
            <li><a href="#finapp-files">The .finapp Files</a></li>
            <li><a href="#clojure-implementation">The Clojure Implementation</a></li>
            <li><a href="#code-generation">Code Generation Process</a></li>
            <li><a href="#ios-implementation">iOS Journey Implementation</a></li>
            <li><a href="#api-integration">API Integration</a></li>
            <li><a href="#bridges">Bridge Layers</a></li>
            <li><a href="#workflow">Complete Workflow</a></li>
        </ul>
    </div>

    <div class="section" id="architecture-overview">
        <h2>Architecture Overview</h2>
        <p>
            The FinApp DSL architecture consists of several key components that work together to enable the creation, validation, and execution of financial business logic across multiple platforms. This guide explains the relationship between these components, with a focus on how they interact to create iOS implementations.
        </p>
        <p>
            At a high level, the architecture consists of:
        </p>
        <ul>
            <li><strong>.finapp files</strong> - Declarative specifications of business requirements</li>
            <li><strong>Clojure implementation</strong> - Runtime behavior and execution logic</li>
            <li><strong>Code generators</strong> - Tools to transform DSL into platform-specific code</li>
            <li><strong>Bridge layers</strong> - Interfaces between different parts of the system</li>
            <li><strong>Platform-specific implementations</strong> - Generated code for iOS, Android, etc.</li>
        </ul>
        <div class="note">
            <p>
                <strong>Key Architecture Principle:</strong> The .finapp files define WHAT needs to be done, while the Clojure implementation defines HOW it should be done.
            </p>
        </div>
    </div>

    <div class="section" id="finapp-files">
        <h2>The .finapp Files</h2>
        <p>
            The .finapp files are written in a custom, declarative syntax that is designed to be readable by both technical and non-technical stakeholders. These files define:
        </p>
        <ul>
            <li>Data models and their properties</li>
            <li>Validation rules</li>
            <li>UI screens and components</li>
            <li>Navigation flows</li>
            <li>API endpoints</li>
            <li>Region-specific configurations</li>
            <li>Customer segment definitions</li>
        </ul>
        <p>
            Here's an example of a .finapp file snippet:
        </p>
        <pre><code>// Data model definition
model Loan {
    id: string required
    customerId: string required
    originalAmount: number required
    currentBalance: number required
    monthlyPayment: number required
    remainingTerm: number required
    interestRate: number required
    isEligibleForTopup: boolean required
}

// Validation rule
validation LoanEligibility {
    on: Loan
    rule: "isEligibleForTopup && status === 'active'"
    message: "Loan must be active and eligible for top-up"
}

// API configuration
api: {
    baseUrl: "https://api.bankingservices.example/v1"
    endpoints: [
        {
            id: getLoan
            path: "/loans/{loanId}"
            method: GET
            params: [
                {
                    name: loanId
                    type: string
                    required
                }
            ]
            response: Loan
        }
    ]
}</code></pre>
        <p>
            The .finapp files serve as the source of truth for business requirements, providing a high-level view of what the application should do without specifying implementation details.
        </p>
    </div>

    <div class="section" id="clojure-implementation">
        <h2>The Clojure Implementation</h2>
        <p>
            While .finapp files specify WHAT to do, the Clojure implementation defines HOW to do it. The Clojure code provides:
        </p>
        <ul>
            <li>Runtime behavior for business rules</li>
            <li>Actual algorithms and calculations</li>
            <li>Integration with external systems</li>
            <li>Data transformation logic</li>
            <li>Implementation of core DSL functions</li>
        </ul>
        <p>
            Here's an example of a Clojure implementation that corresponds to the .finapp validation rule:
        </p>
        <pre><code>;; Clojure implementation of loan eligibility check
(defn check-loan-eligibility
  "Implement the loan eligibility rule with additional validation logic"
  [loan region-code]
  (and
    ;; Basic check from .finapp rule
    (:isEligibleForTopup loan)
    (= "active" (:status loan))
    
    ;; Additional runtime logic
    (when-let [remaining-term (:remainingTerm loan)]
      (>= remaining-term (get-min-remaining-term region-code)))
    
    (not (:isFraudSuspected loan))
    
    ;; Region-specific rules
    (case region-code
      "UK" (>= (:accountAgeMonths loan) 6)
      "HK" (>= (:accountAgeMonths loan) 3)
      true))) ;; Default case for other regions</code></pre>
        <p>
            The Clojure implementation is richer and more detailed than the .finapp specification, as it needs to handle all the complexities of actual execution, including edge cases, error handling, and integration with other systems.
        </p>
    </div>

    <div class="section" id="code-generation">
        <h2>Code Generation Process</h2>
        <p>
            The code generation process combines the .finapp files and Clojure implementation to produce platform-specific code. The process follows these steps:
        </p>
        <ol>
            <li><strong>Parsing</strong>: The .finapp file is parsed into an Abstract Syntax Tree (AST)</li>
            <li><strong>Analysis</strong>: The AST is analyzed for completeness and correctness</li>
            <li><strong>Transformation</strong>: The AST is transformed into platform-specific code models</li>
            <li><strong>Generation</strong>: Code files are generated for each target platform</li>
        </ol>
        <p>
            The code generator uses both the .finapp specification and the Clojure implementation to ensure that the generated code correctly implements the business requirements. For example:
        </p>
        <ul>
            <li>Data models from the .finapp file become native data classes</li>
            <li>Validation rules become validation functions</li>
            <li>Business logic from Clojure becomes native methods</li>
            <li>UI screens become platform-specific components</li>
        </ul>
    </div>

    <div class="section" id="ios-implementation">
        <h2>iOS Journey Implementation</h2>
        <p>
            For iOS implementations, the code generator produces Swift code that can be compiled directly into an iOS app. The journey from .finapp and Clojure to a native iOS implementation involves these steps:
        </p>
        <ol>
            <li>The .finapp file provides the structure of screens, models, and navigation</li>
            <li>The Clojure implementation provides the behavior and business logic</li>
            <li>The code generator translates both into Swift code</li>
            <li>The Swift code is compiled into the iOS app</li>
        </ol>
        <p>
            The generated iOS code is fully native, with no runtime dependencies on the DSL or Clojure. This means that in production:
        </p>
        <ul>
            <li>No bridge layer is used at runtime</li>
            <li>No interpretation happens at runtime</li>
            <li>All business rules are compiled directly into Swift</li>
            <li>The app has native performance characteristics</li>
        </ul>
        <p>
            Here's an example of a generated Swift screen from a .finapp specification:
        </p>
        <pre><code>// Generated from screen TopupAmountSelection in loan-topup.finapp
class TopupAmountSelectionViewController: UIViewController {
    // Properties for screen parameters
    var loanId: String
    var offerId: String
    
    // Data formatting functions
    func formatCurrency(value: Double, region: String) -> String {
        return region == "UK" ? "¬£\(String(format: "%.2f", value))" : "HK$\(String(format: "%.2f", value))"
    }
    
    func getPresetAmounts(minAmount: Double, maxAmount: Double, segment: String) -> [Double] {
        let spread = maxAmount - minAmount
        let step = spread / 4
        return [
            round(minAmount + step),
            round(minAmount + step * 2),
            round(minAmount + step * 3)
        ]
    }
    
    // Lifecycle methods and UI components
    // ...
}</code></pre>
        <p>
            The bridge layer is only used during development and testing, not in the production app. This allows for rapid iteration during development while ensuring high performance in production.
        </p>
    </div>

    <div class="section" id="api-integration">
        <h2>API Integration</h2>
        <p>
            API integration is a key aspect of financial applications. In the FinApp DSL architecture, API integration follows the same pattern of separation between specification and implementation:
        </p>
        <div class="code-comparison">
            <div>
                <h4>.finapp API Specification</h4>
                <pre><code>// API configuration
api: {
    baseUrl: "https://api.bankingservices.example/v1"
    endpoints: [
        {
            id: getLoan
            path: "/loans/{loanId}"
            method: GET
            params: [
                {
                    name: loanId
                    type: string
                    required
                }
            ]
            response: Loan
        }
    ]
}</code></pre>
            </div>
            <div>
                <h4>Clojure API Implementation</h4>
                <pre><code>;; Actual implementation of API client
(defn get-loan 
  "Retrieve loan data from the API"
  [loan-id region-code auth-token]
  (let [base-url (get-region-api-url region-code)
        headers {"Authorization" (str "Bearer " auth-token)
                 "Content-Type" "application/json"
                 "Accept-Language" (get-region-locale region-code)}
        response (http/get (str base-url "/loans/" loan-id)
                          {:headers headers
                           :as :json})]
    (if (= 200 (:status response))
      (:body response)
      (throw (ex-info "Failed to fetch loan data" 
                    {:status (:status response)
                     :error (:body response)})))))</code></pre>
            </div>
        </div>
        <p>
            The code generator uses both the API specification from the .finapp file and the implementation details from the Clojure code to create platform-specific API clients:
        </p>
        <pre><code>// Generated iOS API Client
class LoanAPIClient {
    let baseURL: String
    let authToken: String
    
    init(baseURL: String, authToken: String) {
        self.baseURL = baseURL
        self.authToken = authToken
    }
    
    func getLoan(loanId: String) async throws -> Loan {
        let url = URL(string: "\(baseURL)/loans/\(loanId)")!
        var request = URLRequest(url: url)
        request.httpMethod = "GET"
        request.addValue("Bearer \(authToken)", forHTTPHeaderField: "Authorization")
        request.addValue("application/json", forHTTPHeaderField: "Content-Type")
        
        let (data, response) = try await URLSession.shared.data(for: request)
        
        guard let httpResponse = response as? HTTPURLResponse,
              httpResponse.statusCode == 200 else {
            throw APIError.requestFailed
        }
        
        return try JSONDecoder().decode(Loan.self, from: data)
    }
}</code></pre>
        <p>
            This approach ensures that:
        </p>
        <ul>
            <li>API specifications are clear and maintainable in the .finapp file</li>
            <li>Implementation details like error handling are in the Clojure code</li>
            <li>Generated API clients are optimized for each platform</li>
            <li>Changes to APIs can be made in one place and propagated everywhere</li>
        </ul>
    </div>

    <div class="section" id="bridges">
        <h2>Bridge Layers</h2>
        <p>
            Bridge layers facilitate communication between different parts of the system during development and testing, but are not used in production. The main bridge is the ClojureDSLBridge, which allows JavaScript code to interact with the Clojure implementation.
        </p>
        <p>
            The bridge layer serves these purposes:
        </p>
        <ul>
            <li>Enables interactive development and testing</li>
            <li>Provides a consistent interface across platforms</li>
            <li>Allows testing of business rules before code generation</li>
            <li>Simplifies integration with testing frameworks</li>
        </ul>
        <p>
            In development and testing, the bridge layer is used to:
        </p>
        <pre><code>// In JavaScript test code
const ClojureDSL = require('../../support/bridges/clojure-dsl-bridge');
const FunctionalDSL = ClojureDSL.loadDSL();

// Initialize DSL environment
let dslEnvironment = FunctionalDSL.createGlobalEnvironment();

// Test a business rule
const ruleResult = FunctionalDSL.evaluate(
  FunctionalDSL.makeApplication(
    FunctionalDSL.makeVariable('isEligibleForTopup'),
    [customerData, "UK"]
  ),
  dslEnvironment
);</code></pre>
        <p>
            However, in production iOS apps, there is no bridge layer - all the business rules are compiled directly into Swift code during the code generation process.
        </p>
    </div>

    <div class="section" id="workflow">
        <h2>Complete Workflow</h2>
        <p>
            The complete workflow for developing and deploying a financial application using the FinApp DSL involves these steps:
        </p>
        <ol>
            <li><strong>Domain Modeling</strong>: Define models, rules, and screens in .finapp files</li>
            <li><strong>Implementation</strong>: Create the Clojure implementation of business logic</li>
            <li><strong>Testing</strong>: Use the bridge layer to test business rules</li>
            <li><strong>Code Generation</strong>: Generate platform-specific code</li>
            <li><strong>Compilation</strong>: Compile the generated code into platform-specific apps</li>
            <li><strong>Deployment</strong>: Deploy the apps to production</li>
        </ol>
        <p>
            This workflow allows for:
        </p>
        <ul>
            <li>Clear separation between business requirements and implementation</li>
            <li>Consistent behavior across platforms</li>
            <li>Rapid iteration of business rules</li>
            <li>High performance in production</li>
            <li>Maintainability of complex financial logic</li>
        </ul>
        <div class="note">
            <p>
                <strong>Key Benefit:</strong> By separating WHAT (in .finapp files) from HOW (in Clojure implementation), the FinApp DSL architecture makes it easier to manage complex financial applications across multiple platforms and regions.
            </p>
        </div>
    </div>

    <footer>
        <p>FinApp DSL Documentation &copy; 2023 AppAthanor</p>
    </footer>
</body>
</html> 