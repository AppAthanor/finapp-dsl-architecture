<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FinApp DSL Architecture Guide</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/5.1.0/github-markdown.min.css">
    <link rel="icon" href="https://avatars.githubusercontent.com/u/205288805?s=400&u=826b5f8e51eb0690b6a1da57cfe811a8b68abe3f&v=4">
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            line-height: 1.6;
            color: #24292e;
            max-width: 980px;
            margin: 0 auto;
            padding: 20px;
            background-color: #fff;
        }
        .header {
            border-bottom: 1px solid #eaecef;
            margin-bottom: 20px;
            padding-bottom: 20px;
        }
        .header h1 {
            margin: 0;
            color: #0366d6;
            font-weight: 600;
        }
        .toc {
            background-color: #f6f8fa;
            border: 1px solid #e1e4e8;
            border-radius: 6px;
            padding: 15px 20px;
            margin-bottom: 30px;
        }
        .toc h3 {
            margin-top: 0;
        }
        .toc ul {
            padding-left: 20px;
        }
        .toc li {
            margin-bottom: 8px;
        }
        .section {
            margin-bottom: 40px;
        }
        .section h2 {
            margin-top: 0;
            padding-bottom: 10px;
            border-bottom: 1px solid #eaecef;
        }
        code {
            font-family: SFMono-Regular, Consolas, "Liberation Mono", Menlo, monospace;
            background-color: rgba(27, 31, 35, 0.05);
            padding: 0.2em 0.4em;
            border-radius: 3px;
        }
        pre {
            background-color: #f6f8fa;
            padding: 16px;
            border-radius: 6px;
            overflow: auto;
        }
        pre code {
            background-color: transparent;
            padding: 0;
        }
        .note {
            background-color: #f1f8ff;
            border-left: 4px solid #0366d6;
            padding: 15px;
            margin: 20px 0;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <a href="../../index.html" class="home">← Back to Home</a>
    
    <div class="header">
        <h1>FinApp DSL Architecture Guide</h1>
        <p>A comprehensive guide to the architecture of the FinApp Domain-Specific Language</p>
    </div>

    <div class="toc">
        <h3>Table of Contents</h3>
        <ul>
            <li><a href="#overview">1. Overview</a></li>
            <li><a href="#bdd-features">2. BDD Feature Files</a></li>
            <li><a href="#core-components">3. Core Components</a>
                <ul>
                    <li><a href="#dsl-file">3.1 .finapp DSL File</a></li>
                    <li><a href="#implementation">3.2 Clojure Implementation</a></li>
                    <li><a href="#runtime">3.3 Evaluation Runtime</a></li>
                </ul>
            </li>
            <li><a href="#separation-of-concerns">4. Separation of Concerns</a></li>
            <li><a href="#business-rules">5. Business Rules Engine</a></li>
            <li><a href="#error-handling">6. Error Handling</a>
                <ul>
                    <li><a href="#error-categories">6.1 Error Categories</a></li>
                    <li><a href="#error-hub">6.2 Centralized Error Hub</a></li>
                    <li><a href="#error-handlers">6.3 Error Handlers</a></li>
                </ul>
            </li>
            <li><a href="#extension-points">7. Extension Points</a></li>
            <li><a href="#best-practices">8. Best Practices</a></li>
            <li><a href="#references">9. References</a></li>
        </ul>
    </div>

    <div class="section" id="overview">
        <h2>1. Overview</h2>
        <p>
            The FinApp DSL (Domain-Specific Language) provides a declarative way to express financial business rules, 
            calculations, and customer journeys. It follows a clear separation between the WHAT (business requirements) 
            and the HOW (implementation details), allowing business analysts and developers to work together efficiently.
        </p>
        <p>
            This architecture is designed to address key challenges in financial applications:
        </p>
        <ul>
            <li>Supporting multiple regions with distinct regulatory requirements</li>
            <li>Implementing different business rules for various customer segments</li>
            <li>Maintaining consistency across complex financial calculations</li>
            <li>Providing clear audit trails for business decisions</li>
            <li>Enabling rapid adaptation to changing business requirements</li>
        </ul>
    </div>

    <div class="section" id="bdd-features">
        <h2>2. BDD Feature Files</h2>
        <p>
            The FinApp DSL uses Behavior-Driven Development (BDD) feature files to capture business requirements and acceptance criteria. These files serve as living documentation and executable specifications.
        </p>
        <pre><code>Feature: Loan Top-up for Pre-approved Customers
  As a pre-approved loan customer
  I want to borrow additional funds on my existing loan
  So that I can meet my financial needs without applying for a new loan

  Background:
    Given I am authenticated in the mobile banking app
    And I have an existing loan that is eligible for top-up
    And my current region is set to "&lt;region&gt;"

  Scenario: Successful loan top-up within limits
    When I request a top-up of "&lt;amount&gt;"
    Then I should see a confirmation screen
    And the top-up amount should be added to my existing loan

  Examples:
    | region | amount  |
    | UK     | £5000   |
    | HK     | HK$50000|</code></pre>
    </div>

    <div class="section" id="core-components">
        <h2>3. Core Components</h2>
        
        <div id="dsl-file">
            <h3>3.1 .finapp DSL File</h3>
            <p>
                The .finapp file is where business requirements are expressed declaratively. It defines:
            </p>
            <ul>
                <li>Business models and their relationships</li>
                <li>Validation rules and constraints</li>
                <li>UI components and layouts</li>
                <li>Navigation flows and user journeys</li>
                <li>API integrations and error handling</li>
            </ul>
            <pre><code>// Example .finapp file structure
app LoanTopupApp {
  models {
    model Loan {
      id: string
      amount: number
      term: number
      status: string
      customer: Customer
    }
    
    model TopupOffer {
      loan: Loan
      maxAmount: number
      minAmount: number
      availableTerms: number[]
    }
  }

  validation {
    rule LoanEligibility {
      when: loan.status == "active" 
            && customer.creditScore >= 700
      message: "Customer eligible for loan top-up"
    }
  }

  screens {
    screen TopupOfferScreen {
      input: TopupOffer
      layout: {
        type: "stack"
        children: [
          {
            type: "text"
            text: "Available Top-up Amount"
            style: "heading"
          },
          {
            type: "amount"
            value: offer.maxAmount
            currency: region.currency
          }
        ]
      }
    }
  }
}</code></pre>
        </div>

        <div id="implementation">
            <h3>3.2 Clojure Implementation</h3>
            <p>
                The Clojure implementation provides the runtime behavior for the DSL specifications:
            </p>
            <ul>
                <li>Business rule implementations</li>
                <li>Data transformations and calculations</li>
                <li>Integration with external systems</li>
                <li>Platform-specific optimizations</li>
            </ul>
            <pre><code>;; Example Clojure implementation
(ns finapp-dsl.loan-topup
  (:require [finapp-dsl.core :as dsl]
            [finapp-dsl.validation :as val]))

(defn calculate-max-topup
  [loan customer region]
  (let [base-amount (* (:amount loan) 0.5)
        credit-factor (/ (:credit_score customer) 1000)
        regional-limit (get-in region [:rules :max_topup])]
    (min (* base-amount credit-factor) 
         regional-limit)))

(defn create-topup-offer
  [loan customer region]
  (when (val/check-eligibility loan customer)
    {:loan loan
     :maxAmount (calculate-max-topup loan customer region)
     :minAmount (get-in region [:rules :min_topup])
     :availableTerms [12 24 36 48]}))</code></pre>
        </div>

        <div class="section" id="runtime">
            <h3>3.3 Evaluation Runtime</h3>
            <p>
                The evaluation runtime is the low-level execution engine that powers rule evaluation in the FinApp DSL. 
                It provides the fundamental building blocks that the Business Rules Engine (Section 5) builds upon.
            </p>
            <p>
                Key responsibilities of the runtime include:
            </p>
            <ul>
                <li>Expression evaluation in specific environments</li>
                <li>Variable binding and resolution</li>
                <li>Function application and composition</li>
                <li>Region and segment-specific rule resolution</li>
            </ul>
            <pre><code>;; Example of runtime evaluation
(require '[finapp-dsl.core :as dsl])

;; Create an evaluation environment
(def env 
  (dsl/make-environment 
    {"customer" {:id "C123", :credit_score 750}}))

;; Evaluate a simple expression
(dsl/evaluate 
  (dsl/make-application :credit_score 
    [(dsl/make-variable "customer")]) 
  env)
;; => 750</code></pre>
            <p>
                The runtime focuses on the mechanics of evaluation, while the Business Rules Engine 
                (Section 5) provides the complete system for defining and managing business rules.
            </p>
        </div>

        <div class="section" id="separation-of-concerns">
            <h2>4. Separation of Concerns</h2>
            <p>
                The FinApp DSL architecture maintains a clear separation between:
            </p>
            <ul>
                <li><strong>WHAT</strong> - Business requirements in .finapp files</li>
                <li><strong>HOW</strong> - Implementation details in Clojure</li>
            </ul>
            <p>
                This separation allows:
            </p>
            <ul>
                <li>Business analysts to focus on requirements without implementation details</li>
                <li>Developers to optimize implementations without affecting business logic</li>
                <li>Clear traceability between requirements and implementation</li>
                <li>Independent evolution of business rules and technical implementation</li>
            </ul>
            <div class="note">
                <p>
                    The separation between WHAT and HOW is maintained through all aspects of the system,
                    from business rules to error handling and UI components.
                </p>
            </div>
        </div>

        <div class="section" id="business-rules">
            <h2>5. Business Rules Engine</h2>
            <p>
                The Business Rules Engine builds on the Evaluation Runtime (Section 3.3) to provide a complete 
                system for defining, managing, and executing business rules. While the runtime handles the 
                low-level evaluation mechanics, the Business Rules Engine adds:
            </p>
            <ul>
                <li>Declarative rule definitions in .finapp files</li>
                <li>Rule composition and reuse</li>
                <li>Versioning and audit trails</li>
                <li>Testing and validation frameworks</li>
                <li>Integration with the broader application architecture</li>
            </ul>
            <pre><code>// Rule definition in .finapp
rules {
  rule LoanEligibility {
    when: customer.credit_score >= 700 
          && customer.income >= minimum_income
    then: {
      eligible: true,
      max_amount: calculate_loan_limit(customer)
    }
  }
}

// Rule implementation in Clojure
(defn loan-eligibility-rule
  [customer min-income]
  (let [credit-score (:credit_score customer)
        income (:income customer)]
    (when (and (>= credit-score 700)
               (>= income min-income))
      {:eligible true
       :max-amount (calculate-loan-limit customer)})))</code></pre>
            <p>
                The Business Rules Engine provides higher-level features that make rules:
            </p>
            <ul>
                <li>Easy to understand and maintain</li>
                <li>Consistent across the application</li>
                <li>Testable and verifiable</li>
                <li>Adaptable to changing business needs</li>
            </ul>
            <div class="note">
                <p>
                    <strong>Key Distinction:</strong> The Evaluation Runtime (3.3) provides the foundational 
                    mechanics for rule evaluation, while the Business Rules Engine builds on this foundation 
                    to provide a complete business rules management system.
                </p>
            </div>
        </div>

        <div class="section" id="error-handling">
            <h2>6. Error Handling</h2>
            <p>
                The FinApp DSL provides a comprehensive error handling framework that ensures consistent error management across the application.
            </p>
            
            <div id="error-categories">
                <h3>6.1 Error Categories</h3>
                <p>
                    The DSL defines several error categories to handle different types of errors consistently:
                </p>
                <pre><code>// Error Categories in DSL
errors {
  category NetworkError {
    codes: [408, 502, 503, 504]
    severity: high
    retryable: true
  }
  
  category ValidationError {
    severity: medium
    retryable: false
  }
  
  category AuthenticationError {
    codes: [401]
    severity: high
    retryable: false
  }
  
  category AuthorisationError {
    codes: [403]
    severity: high
    retryable: false
  }
}</code></pre>
            </div>

            <div id="error-hub">
                <h3>6.2 Centralized Error Hub</h3>
                <p>
                    Each journey contains a centralized error hub that defines error ownership and handling strategies:
                </p>
                <pre><code>// Error Hub in DSL
journey LoanTopupJourney {
  errorHub {
    ownership {
      owns: [
        IneligibleLoan,
        InsufficientIncome,
        AmountTooLow,
        AmountTooHigh
      ]
      delegates: [
        NetworkError,
        AuthenticationError,
        AuthorisationError
      ]
    }
  }
}</code></pre>
                <p>
                    The error hub provides:
                </p>
                <ul>
                    <li>Clear ownership boundaries between journey and platform</li>
                    <li>Explicit delegation of platform-level errors</li>
                    <li>Centralized error flow management</li>
                    <li>Consistent error handling patterns</li>
                </ul>
            </div>

            <div id="error-handlers">
                <h3>6.3 Error Handlers</h3>
                <p>
                    Error handlers define how specific errors should be presented and managed:
                </p>
                <pre><code>// Error Handlers in DSL
handlers {
  IneligibleLoan: {
    display: ErrorBanner
    location: "TopupOfferScreen"
    properties: {
      message: "You are not eligible for a loan top-up at this time"
      actionText: "View Requirements"
      action: navigate(EligibilityRequirementsScreen)
    }
  }
  
  NetworkError: {
    display: RetryDialog
    properties: {
      message: "Connection lost. Please check your internet connection."
      retryText: "Try Again"
      cancelText: "Cancel"
    }
    recovery: {
      allowRetry: true
      maxRetries: 3
      backoffStrategy: "exponential"
    }
  }
}</code></pre>
                <p>
                    The platform provides default handlers for common errors, which can be overridden by journey-specific handlers when needed.
                </p>
                <div class="note">
                    <p>
                        <strong>Key Benefits:</strong>
                        <ul>
                            <li>Consistent error handling across the application</li>
                            <li>Clear separation between error definition and handling</li>
                            <li>Flexible recovery strategies</li>
                            <li>Improved user experience during error scenarios</li>
                        </ul>
                    </p>
                </div>
            </div>
        </div>

        <div class="section" id="extension-points">
            <h2>7. Extension Points</h2>
            <p>
                The FinApp DSL architecture provides several extension points for customization:
            </p>
            <ul>
                <li>Custom functions and operations</li>
                <li>Platform-specific UI components</li>
                <li>Integration adapters for external systems</li>
                <li>Custom validation rules and error handlers</li>
            </ul>
            <pre><code>// Example of custom extension
extensions {
  functions {
    calculateInterestRate(amount: number, term: number): number
    formatCurrency(amount: number, region: string): string
  }
  
  components {
    CustomAmountInput: {
      props: {
        value: number
        currency: string
        onChange: (value: number) => void
      }
    }
  }
}</code></pre>
        </div>

        <div class="section" id="best-practices">
            <h2>8. Best Practices</h2>
            <p>
                When working with the FinApp DSL architecture:
            </p>
            <ul>
                <li>Keep business rules in .finapp files simple and declarative</li>
                <li>Use the Clojure implementation for complex calculations</li>
                <li>Maintain clear separation between WHAT and HOW</li>
                <li>Document all custom extensions and implementations</li>
                <li>Write comprehensive tests at both DSL and implementation levels</li>
            </ul>
        </div>

        <div class="section" id="references">
            <h2>9. References</h2>
            <ul>
                <li><a href="../api/index.html">API Reference</a> - Complete API documentation</li>
                <li><a href="../rfc/error-handling.html">Error Handling RFC</a> - Detailed error handling guide</li>
                <li><a href="../examples/index.html">Examples</a> - Sample applications and use cases</li>
            </ul>
        </div>

    <footer>
        <p>FinApp DSL Documentation &copy; 2023 AppAthanor</p>
    </footer>
</body>
</html> 