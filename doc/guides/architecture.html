<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FinApp DSL Architecture Guide</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/5.1.0/github-markdown.min.css">
    <link rel="icon" href="https://avatars.githubusercontent.com/u/205288805?s=400&u=826b5f8e51eb0690b6a1da57cfe811a8b68abe3f&v=4">
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            line-height: 1.6;
            color: #24292e;
            max-width: 980px;
            margin: 0 auto;
            padding: 20px;
            background-color: #fff;
        }
        .header {
            border-bottom: 1px solid #eaecef;
            margin-bottom: 20px;
            padding-bottom: 20px;
        }
        .header h1 {
            margin: 0;
            color: #0366d6;
            font-weight: 600;
        }
        .toc {
            background-color: #f6f8fa;
            border: 1px solid #e1e4e8;
            border-radius: 6px;
            padding: 15px 20px;
            margin-bottom: 30px;
        }
        .toc h3 {
            margin-top: 0;
        }
        .toc ul {
            padding-left: 20px;
        }
        .toc li {
            margin-bottom: 8px;
        }
        .section {
            margin-bottom: 40px;
        }
        .section h2 {
            margin-top: 0;
            padding-bottom: 10px;
            border-bottom: 1px solid #eaecef;
        }
        code {
            font-family: SFMono-Regular, Consolas, "Liberation Mono", Menlo, monospace;
            background-color: rgba(27, 31, 35, 0.05);
            padding: 0.2em 0.4em;
            border-radius: 3px;
        }
        pre {
            background-color: #f6f8fa;
            padding: 16px;
            border-radius: 6px;
            overflow: auto;
        }
        pre code {
            background-color: transparent;
            padding: 0;
        }
        .note {
            background-color: #f1f8ff;
            border-left: 4px solid #0366d6;
            padding: 15px;
            margin: 20px 0;
            border-radius: 3px;
        }
        .warning {
            background-color: #fff5b1;
            border-left: 4px solid #ff9800;
            padding: 15px;
            margin: 20px 0;
            border-radius: 3px;
        }
        footer {
            margin-top: 50px;
            padding-top: 20px;
            border-top: 1px solid #eaecef;
            color: #586069;
            font-size: 14px;
        }
        a.home {
            display: inline-block;
            margin-bottom: 20px;
            color: #0366d6;
            text-decoration: none;
        }
        a.home:hover {
            text-decoration: underline;
        }
        .architecture-diagram {
            max-width: 100%;
            margin: 20px 0;
            border: 1px solid #e1e4e8;
            border-radius: 6px;
        }
    </style>
</head>
<body>
    <a href="../../index.html" class="home">‚Üê Back to Home</a>
    
    <div class="header">
        <h1>FinApp DSL Architecture Guide</h1>
        <p>A comprehensive guide to the architecture of the FinApp Domain-Specific Language</p>
    </div>

    <div class="toc">
        <h3>Table of Contents</h3>
        <ul>
            <li><a href="#overview">1. Overview</a></li>
            <li><a href="#core-components">2. Core Components</a>
                <ul>
                    <li><a href="#dsl-file">2.1 .finapp DSL File</a></li>
                    <li><a href="#implementation">2.2 Clojure Implementation</a></li>
                    <li><a href="#runtime">2.3 Evaluation Runtime</a></li>
                </ul>
            </li>
            <li><a href="#separation-of-concerns">3. Separation of Concerns</a>
                <ul>
                    <li><a href="#what-layer">3.1 WHAT Layer (.finapp)</a></li>
                    <li><a href="#how-layer">3.2 HOW Layer (Clojure)</a></li>
                </ul>
            </li>
            <li><a href="#business-rules">4. Business Rules Engine</a></li>
            <li><a href="#api-architecture">5. API Architecture</a></li>
            <li><a href="#multi-region">6. Multi-Region Support</a></li>
            <li><a href="#segmentation">7. Customer Segmentation</a></li>
            <li><a href="#error-handling">8. Error Handling</a>
                <ul>
                    <li><a href="#error-framework">8.1 Error Handling Framework</a></li>
                    <li><a href="#centralised-hub">8.2 Centralised Error Hub</a></li>
                    <li><a href="#implementation-strategy">8.3 Implementation Strategy</a></li>
                </ul>
            </li>
            <li><a href="#extension-points">9. Extension Points</a></li>
            <li><a href="#best-practices">10. Best Practices</a></li>
            <li><a href="#references">11. References</a></li>
        </ul>
    </div>

    <div class="section" id="overview">
        <h2>1. Overview</h2>
        <p>
            The FinApp DSL (Domain-Specific Language) provides a declarative way to express financial business rules, 
            calculations, and customer journeys. It follows a clear separation between the WHAT (business requirements) 
            and the HOW (implementation details), allowing business analysts and developers to work together efficiently.
        </p>
        <p>
            This architecture is designed to address key challenges in financial applications:
        </p>
        <ul>
            <li>Supporting multiple regions with distinct regulatory requirements</li>
            <li>Implementing different business rules for various customer segments</li>
            <li>Maintaining consistency across complex financial calculations</li>
            <li>Providing clear audit trails for business decisions</li>
            <li>Enabling rapid adaptation to changing business requirements</li>
        </ul>
    </div>

    <div class="section" id="core-components">
        <h2>2. Core Components</h2>
        
        <div id="dsl-file">
            <h3>2.1 .finapp DSL File</h3>
            <p>
                The <code>.finapp</code> file is the primary interface for defining business requirements. It uses a 
                domain-specific syntax that is readable by business analysts and serves as the source of truth for 
                the application's business logic.
            </p>
            <pre><code>// Example .finapp file structure
app LoanTopUp {
  regions: [UK, US, AU]
  
  model Loan {
    amount: Money
    term: Int
    interestRate: Decimal
    
    validation LoanEligibility {
      rule: min_credit_score > 700
    }
  }
  
  segment PremiumCustomer {
    criteria: customer.tier == "premium"
    rules: {
      max_loan_amount: 50000
    }
  }
  
  screen LoanApplicationScreen {
    components: [
      LoanAmountEntry,
      TermSelector,
      SubmitButton
    ]
    
    navigation: {
      next: ConfirmationScreen
      back: DashboardScreen
    }
  }
}</code></pre>
        </div>
        
        <div id="implementation">
            <h3>2.2 Clojure Implementation</h3>
            <p>
                The Clojure implementation files translate the declarative DSL into executable code. These files 
                define the "how" of the business requirements, implementing the actual business logic while 
                maintaining alignment with the DSL specifications.
            </p>
            <pre><code>;; Example Clojure Implementation
(ns loan-topup
  (:require [finapp-dsl.core :as dsl]))

(def eligibility-rule
  (dsl/make-lambda ["customer"]
    (dsl/make-application >= 
      [(dsl/make-application :credit_score [customer-var]) 700])))

(def max-loan-amount
  (dsl/make-lambda ["customer"]
    (dsl/make-if
      (dsl/make-application = [(dsl/make-application :tier [customer-var]) "premium"])
      (dsl/make-quoted 50000)
      (dsl/make-quoted 25000))))</code></pre>
        </div>
        
        <div id="runtime">
            <h3>2.3 Evaluation Runtime</h3>
            <p>
                The evaluation runtime interprets and executes the business rules defined in the DSL. It provides:
            </p>
            <ul>
                <li>Expression evaluation in the context of specific environments</li>
                <li>Variable binding and resolution</li>
                <li>Function application and composition</li>
                <li>Region and segment-specific rule resolution</li>
            </ul>
            <pre><code>;; Runtime evaluation example
(require '[finapp-dsl.core :as dsl])

(def customer {:id "C123", :credit_score 750, :tier "premium"})

(def environment (dsl/make-environment {"customer" customer}))

(dsl/evaluate eligibility-rule environment)
;; => true

(dsl/evaluate max-loan-amount environment)
;; => 50000</code></pre>
        </div>
    </div>

    <div class="section" id="separation-of-concerns">
        <h2>3. Separation of Concerns</h2>
        
        <div id="what-layer">
            <h3>3.1 WHAT Layer (.finapp)</h3>
            <p>
                The WHAT layer, represented by <code>.finapp</code> files, focuses on:
            </p>
            <ul>
                <li>Defining business entities and their relationships</li>
                <li>Specifying validation rules and constraints</li>
                <li>Declaring customer segments and their criteria</li>
                <li>Outlining UI components and navigation flows</li>
                <li>Specifying API endpoints and their behaviors</li>
            </ul>
            <p>
                This layer is designed to be accessible to business analysts and product owners, allowing them to 
                directly verify that the business requirements are correctly captured.
            </p>
        </div>
        
        <div id="how-layer">
            <h3>3.2 HOW Layer (Clojure)</h3>
            <p>
                The HOW layer, implemented in Clojure, focuses on:
            </p>
            <ul>
                <li>Implementing the execution logic for business rules</li>
                <li>Defining the computational aspects of financial calculations</li>
                <li>Building the evaluation system for expressions</li>
                <li>Implementing region-specific variations of rules</li>
                <li>Creating runtime environments for rule evaluation</li>
            </ul>
            <p>
                This layer is primarily the domain of developers, who translate the business requirements into 
                efficient, maintainable, and testable code.
            </p>
        </div>
    </div>

    <div class="section" id="business-rules">
        <h2>4. Business Rules Engine</h2>
        <p>
            The business rules engine is the core of the FinApp DSL, providing a flexible way to encode complex 
            financial decision logic. The engine itself is implemented in Clojure, which serves as the "HOW" layer
            that executes the rules defined in the ".finapp" DSL files (the "WHAT" layer).
        </p>
        <p>
            Key features of the business rules engine include:
        </p>
        <ul>
            <li><strong>Composability</strong> - Rules can be combined to form more complex rules</li>
            <li><strong>Reusability</strong> - Rules can be shared across different parts of the application</li>
            <li><strong>Testability</strong> - Rules can be tested in isolation with specific inputs</li>
            <li><strong>Versioning</strong> - Rules can be versioned to maintain backward compatibility</li>
            <li><strong>Auditability</strong> - Rule evaluations can be traced and explained</li>
        </ul>
        <p>
            Business rules are defined declaratively in the .finapp DSL file:
        </p>
        <pre><code>// DSL definition of rules
rules {
  rule eligibility {
    description: "Determine if a customer is eligible for a loan"
    inputs: [customer, loan_request]
    condition: customer.credit_score >= 700 && 
               loan_request.amount <= max_loan_amount(customer)
  }
  
  rule max_loan_amount {
    description: "Calculate the maximum loan amount for a customer"
    inputs: [customer]
    formula: customer.tier == "premium" ? 50000 : 25000
  }
}</code></pre>

        <p>
            These rules are then implemented in Clojure, which provides the actual execution logic:
        </p>
        <pre><code>;; Clojure implementation of the rules
(defn max-loan-amount 
  "Calculate the maximum loan amount for a customer"
  [customer]
  (if (= (:tier customer) "premium")
    50000
    25000))

(defn eligibility-rule
  "Determine if a customer is eligible for a loan"
  [customer loan-request]
  (and (>= (:credit_score customer) 700)
       (<= (:amount loan-request) (max-loan-amount customer))))</code></pre>

        <p>
            The Clojure implementation provides the runtime behavior for the rules defined in the DSL, ensuring
            that business logic is executed consistently according to the specifications.
        </p>
    </div>

    <div class="section" id="api-architecture">
        <h2>5. API Architecture</h2>
        <p>
            The FinApp DSL includes a comprehensive API framework for defining and consuming APIs:
        </p>
        
        <h3>5.1 API Definition</h3>
        <p>
            APIs are defined declaratively in the .finapp DSL file, including endpoints, request/response structures, 
            and error mappings:
        </p>
        <pre><code>// API definition in DSL
api LoanTopupService {
  endpoint: "/api/loan-topup"
  
  operation checkEligibility {
    method: GET
    request: {
      loanId: string
      customerId: string
    }
    response: {
      eligible: boolean
      maxAmount: number?
      reason: string?
    }
    
    errorMapping {
      400: {
        "LOAN_NOT_ELIGIBLE" -> IneligibleLoan
        "INCOME_BELOW_THRESHOLD" -> InsufficientIncome
      }
      401: AuthenticationError
      403: AuthorisationError
      5xx: NetworkError
    }
  }
  
  operation createTopup {
    method: POST
    request: {
      loanId: string
      customerId: string
      amount: number
      term: number?
    }
    response: {
      topupId: string
      status: string
      processingDate: date
      disbursementDate: date
    }
    
    errorMapping {
      400: {
        "AMOUNT_TOO_LOW" -> AmountTooLow
        "AMOUNT_TOO_HIGH" -> AmountTooHigh
      }
      401: AuthenticationError
      403: AuthorisationError
      5xx: NetworkError
    }
  }
}</code></pre>

        <h3>5.2 API Configuration</h3>
        <p>
            API configurations include base URLs, authentication methods, and endpoint mappings:
        </p>
        <pre><code>// API configuration
api: {
  baseUrl: "https://api.bankingservices.example/v1"
  mock: true
  endpoints: [
    {
      id: getLoans
      path: "/loans"
      method: GET
      response: Loan[]
    },
    {
      id: createTopup
      path: "/loans/topup"
      method: POST
      body: {
        loanId: string required,
        amount: number required,
        interestRate: number required
      }
      response: TopupConfirmation
    }
  ]
}</code></pre>

        <h3>5.3 API Integration</h3>
        <p>
            APIs can be invoked from various parts of the application:
        </p>
        <ul>
            <li><strong>Screen Loading</strong> - API calls triggered when screens load</li>
            <li><strong>User Actions</strong> - API calls triggered by user interactions</li>
            <li><strong>Background Processing</strong> - API calls for background tasks</li>
        </ul>
        <pre><code>// API integration in screens
screen LoansOverview {
  // ...
  onLoad: {
    apiCall: getLoans
  }
  
  // ...
  components: [
    {
      type: "button"
      label: "Confirm Top-up"
      action: "createTopup" // This will trigger the API call
    }
  ]
}</code></pre>

        <h3>5.4 API Error Handling</h3>
        <p>
            The API architecture integrates tightly with the error handling framework:
        </p>
        <ul>
            <li>HTTP status codes are mapped to domain-specific errors</li>
            <li>Error payloads can include additional context for error handling</li>
            <li>API errors trigger the appropriate error handlers in the journey</li>
        </ul>
        <p>
            In the Clojure implementation, API error handling is managed through the error mapping functions:
        </p>
        <pre><code>;; API Error Mappings
(def api-error-mappings
  {:LoanTopupService
   {:checkEligibility
    {:400 {"LOAN_NOT_ELIGIBLE" :IneligibleLoan
           "INCOME_BELOW_THRESHOLD" :InsufficientIncome}
     :401 :AuthenticationError
     :403 :AuthorisationError
     :5xx :NetworkError}}})
     
(defn map-api-error
  "Maps an API error response to a domain error"
  [service operation status-code error-message]
  (let [status-mappings (get-in api-error-mappings [service operation])
        status-key (if (and (>= status-code 500) (< status-code 600))
                     :5xx
                     status-code)
        error-mapping (get status-mappings status-key)]
    (cond
      (map? error-mapping) (get error-mapping error-message)
      (keyword? error-mapping) error-mapping
      :else :UnknownError)))</code></pre>
    </div>

    <div class="section" id="multi-region">
        <h2>6. Multi-Region Support</h2>
        <p>
            The FinApp DSL architecture provides native support for multi-region applications, allowing:
        </p>
        <ul>
            <li>Definition of region-specific business rules and constraints</li>
            <li>Localization of UI components and messages</li>
            <li>Region-specific validation rules and calculations</li>
            <li>Different workflows based on regional regulatory requirements</li>
        </ul>
        <pre><code>// Multi-region definition in DSL
regions {
  region UK {
    currency: GBP
    dateFormat: "DD/MM/YYYY"
    rules: {
      max_loan_term: 60
      min_loan_amount: 1000
    }
  }
  
  region US {
    currency: USD
    dateFormat: "MM/DD/YYYY"
    rules: {
      max_loan_term: 72
      min_loan_amount: 1500
    }
  }
}</code></pre>
        <p>
            At runtime, the appropriate region context is applied to ensure that all business rules and calculations 
            adhere to the specific requirements of the region.
        </p>
    </div>

    <div class="section" id="segmentation">
        <h2>7. Customer Segmentation</h2>
        <p>
            Customer segmentation allows for tailored experiences and rules based on customer attributes:
        </p>
        <ul>
            <li>Defining segment criteria based on customer attributes</li>
            <li>Applying segment-specific business rules</li>
            <li>Customizing UI and workflows per segment</li>
            <li>Combining segmentation with regional variations</li>
        </ul>
        <pre><code>// Customer segmentation in DSL
segments {
  segment Premium {
    criteria: customer.tier == "premium" && customer.tenure >= 2
    rules: {
      interest_rate_discount: 0.5
      expedited_processing: true
    }
  }
  
  segment New {
    criteria: customer.tenure < 1
    rules: {
      max_loan_amount: 10000
      additional_verification: true
    }
  }
}</code></pre>
        <p>
            The segmentation system allows for dynamic determination of a customer's segments 
            at runtime, enabling personalized experiences without modifying the core business logic.
        </p>
    </div>

    <div class="section" id="error-handling">
        <h2>8. Error Handling</h2>
        
        <div id="error-framework">
            <h3>8.1 Error Handling Framework</h3>
            <p>
                The FinApp DSL includes a robust error handling framework that provides:
            </p>
            <ul>
                <li>Explicit error definition and categorization</li>
                <li>Clear ownership boundaries between journey and platform</li>
                <li>Declarative specification of error handling behaviors</li>
                <li>Consistent user experience across error scenarios</li>
                <li>Centralized management of error flows</li>
            </ul>
            <p>
                This framework addresses the gap between the <code>.finapp</code> (WHAT) and Clojure implementation (HOW) 
                files by making error handling explicit and declarative.
            </p>
            <pre><code>// Error definition in DSL
errors {
  category NetworkError {
    codes: [408, 502, 503, 504]
    severity: high
    retryable: true
  }
  
  error InsufficientFunds extends ValidationError {
    code: "PAYMENT_001"
    message: "Insufficient funds available"
  }
}</code></pre>
        </div>
        
        <div id="centralised-hub">
            <h3>8.2 Centralised Error Hub</h3>
            <p>
                Each journey contains a centralised error hub that clearly defines:
            </p>
            <ol>
                <li>Which errors the journey owns vs delegates to the platform</li>
                <li>How owned errors should be handled</li>
                <li>Recovery strategies for different error scenarios</li>
            </ol>
            <pre><code>// Centralised Error Hub in DSL
journey PaymentJourney {
  // Journey definition
  // ...
  
  errorHub {
    // Define which errors this journey owns vs delegates to platform
    ownership {
      owns: [InsufficientFunds, PaymentLimitExceeded]
      delegates: [NetworkError, AuthenticationError]
    }
    
    // Define handlers for owned errors
    handlers {
      InsufficientFunds: {
        display: ErrorBanner
        location: "PaymentScreen"
        properties: {
          message: error.message
          actionText: "Check balance"
          action: navigate(AccountDetailsScreen)
        }
        recovery: {
          allowRetry: true
          alternativeFlow: navigate(AccountListScreen)
        }
      }
    }
  }
}</code></pre>
            <p>
                The platform also defines default handlers for delegated errors, ensuring that all error scenarios 
                have appropriate handling strategies.
            </p>
        </div>
        
        <div id="implementation-strategy">
            <h3>8.3 Implementation Strategy</h3>
            <p>
                The error handling implementation follows these key principles:
            </p>
            <ul>
                <li><strong>Separation of Concerns</strong> - Error definition is separate from handling logic</li>
                <li><strong>Explicit Ownership</strong> - Clear boundaries between journey and platform responsibilities</li>
                <li><strong>Consistency</strong> - Standardized error patterns across the application</li>
                <li><strong>Recoverability</strong> - Well-defined recovery strategies for different error types</li>
                <li><strong>User Experience</strong> - Error presentation tailored to the context and severity</li>
            </ul>
            <p>
                This approach significantly improves the maintainability and consistency of error handling throughout 
                the application, while providing a better user experience during error scenarios.
            </p>
            <div class="note">
                <p>
                    <strong>Note:</strong> For a detailed explanation of the error handling framework, 
                    refer to the <a href="../rfc/error-handling.html">Error Handling RFC</a>.
                </p>
            </div>
        </div>
    </div>

    <div class="section" id="extension-points">
        <h2>9. Extension Points</h2>
        <p>
            The FinApp DSL architecture provides several extension points for customizing and enhancing the system:
        </p>
        <ul>
            <li><strong>Custom Functions</strong> - Adding new functions to the expression language</li>
            <li><strong>Rule Transforms</strong> - Preprocessing rules for optimization or analysis</li>
            <li><strong>Middleware</strong> - Intercepting and modifying rule evaluation</li>
            <li><strong>Event Hooks</strong> - Reacting to specific events in the evaluation process</li>
            <li><strong>Custom Components</strong> - Extending the UI component library</li>
        </ul>
        <pre><code>;; Example of extending with custom functions
(defn register-custom-functions [registry]
  (-> registry
      (assoc "calculate-interest" 
         (fn [principal rate term]
           (* principal rate (/ term 12))))
      (assoc "apply-early-repayment" 
         (fn [loan-amount term months-elapsed]
           ;; implementation
           ))
      ;; Add more custom functions as needed
      ))</code></pre>
    </div>

    <div class="section" id="best-practices">
        <h2>10. Best Practices</h2>
        <p>
            When working with the FinApp DSL architecture, consider these best practices:
        </p>
        <ul>
            <li><strong>Keep DSL files focused</strong> - Each .finapp file should represent a coherent domain concept</li>
            <li><strong>Maintain alignment</strong> - Ensure the Clojure implementation matches the DSL declarations</li>
            <li><strong>Write tests for rules</strong> - Validate rule behavior with comprehensive test cases</li>
            <li><strong>Document business intent</strong> - Add descriptions to rules explaining their business purpose</li>
            <li><strong>Reuse common patterns</strong> - Extract shared logic into reusable rules and functions</li>
            <li><strong>Version critical rules</strong> - Use versioning for rules that might change over time</li>
            <li><strong>Plan for regional variations</strong> - Design rules with multi-region support in mind</li>
            <li><strong>Handle errors explicitly</strong> - Define error scenarios and their handling in the DSL</li>
        </ul>
        <div class="warning">
            <p>
                <strong>Warning:</strong> Avoid embedding complex business logic directly in the Clojure implementation 
                without corresponding DSL declarations. This creates a disconnect between the business requirements and 
                implementation.
            </p>
        </div>
    </div>

    <div class="section" id="references">
        <h2>11. References</h2>
        <ul>
            <li><a href="../api/index.html">API Reference</a> - Complete API documentation for the FinApp DSL</li>
            <li><a href="../concepts/index.html">Core Concepts</a> - Detailed explanations of the DSL's core concepts</li>
            <li><a href="../examples/loan-topup.html">Loan Top-up Example</a> - A complete example implementation</li>
            <li><a href="../rfc/error-handling.html">Error Handling RFC</a> - Detailed error handling framework specification</li>
            <li><a href="getting-started.html">Getting Started Guide</a> - Guide for new users of the FinApp DSL</li>
        </ul>
    </div>

    <footer>
        <p>
            &copy; 2023 FinApp DSL Team. All rights reserved.
        </p>
    </footer>
</body>
</html> 